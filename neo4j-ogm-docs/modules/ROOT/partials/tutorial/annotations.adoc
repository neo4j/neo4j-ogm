[[tutorial:annotations]]
= Annotating the domain model

Much like Hibernate or JPA, Neo4j-OGM allows you to annotate your POJOs in order to map them to nodes, relationships and properties in the graph.


[[tutorial:annotations:nodes]]
== Node Entities

POJOs annotated with `@NodeEntity` will be represented as nodes in the graph.

The label assigned to this node can be specified via the `label` property on the annotation;
if not specified, it will default to the simple class name of the entity.
Each parent class in addition also contributes a label to the entity.
This is useful when we want to retrieve collections of super types.

Let's go ahead and annotate all our node entities in the code we wrote earlier.

[source, java]
----
@NodeEntity
public class Movie {
    String title;
    List<Actor> actors;
    List<Person> directors;
    List<Reviewer> reviewers;
}

@NodeEntity
public class Person {
    String name;
}
----


[[tutorial:annotations:relationships]]
== Relationships

Next up, the relationships between the nodes.

Every field in an entity that references another entity is backed by a relationship in the graph.
The `@Relationship` annotation allows you to specify both the type of the relationship and the direction.
By default, the direction is assumed to be `OUTGOING` and the type is the UPPER_SNAKE_CASE field name.

We're going to be specific about the relationship type to avoid using the default and also make it easier to refactor classes later
by not being dependent on the field name.
Again, we are going to modify the code we saw in the last section:

[source, java]
----
@NodeEntity
public class Movie {
    String title;

    @Relationship(type = "ACTED_IN", direction = Relationship.Direction.INCOMING)
    List<Actor> actors;

    @Relationship(type = "DIRECTED", direction = Relationship.Direction.INCOMING)
    List<Person> directors;

    @Relationship(type = "REVIEWED", direction = Relationship.Direction.INCOMING)
    List<Reviewer> reviewers;
}
----


[[tutorial:annotations:relationship-entities]]
== Relationship Entities

Sometimes something isn't quite a Node entity.

In this demo the remaining classes to annotate are `Actor` and `Reviewer`.
As discussed earlier, this is a relationship entity since it manages the underlying `ACTED_IN` and `REVIEWED` relations between a `Movie` and `Person`.
They aren't simple relationships because they hold properties like `roles` or `summary` and `score`.

A relationship entity must be annotated with `@RelationshipEntity` and also the type of relationship.
Additionally, it needs a definition of where it comes from (`Person`) and where it goes to (`Movie`).

We are also going to indicate to Neo4j-OGM the start and end node of this relationship.

[source, java]
----
@RelationshipEntity(type = "ACTED_IN")
public class Actor {

    List<String> roles;

	@StartNode
    Person person;

    @EndNode
    Movie movie;
}

@RelationshipEntity("REVIEWED")
public class Reviewer {

    @Property("summary")
    String review;

    int rating;

    @EndNode
    Movie movie;

    @StartNode
    Person person;
}
----


[[tutorial:annotations:graphid]]
== Identifiers

Every node and relationship persisted to the graph must have an id.
Neo4j-OGM uses this to identify and re-connect the entity to the graph in memory.
Identifier may be either a primary id or a native graph id.

- primary id - any property annotated with `@Id`, set by the user and optionally with `@GeneratedValue` annotation
- native id - this id corresponds to the id generated by the  Neo4j database when a node or relationship is first saved, must be of type `Long`

[WARNING]
***Do not*** rely on native id for long-running applications.
Neo4j will reuse deleted node id's.
It is recommended users come up with their own unique identifier for their domain objects (or use a UUID).

See xref:reference.adoc#reference:annotating-entities:entity-identifier[Node Entities] for more information.

Our entities will now also define the `@Id` fields.
For the `Movie` we have chosen the _title_ and for the `Person` the _name_ property.
In a real-world scenario names and titles cannot be seen as unique, but for this example it is enough.

[source, java]
----
@NodeEntity
public class Movie {
    @Id
    String title;

    @Relationship(type = "ACTED_IN", direction = Relationship.Direction.INCOMING)
    List<Actor> actors;

    @Relationship(type = "DIRECTED", direction = Relationship.Direction.INCOMING)
    List<Person> directors;

    @Relationship(type = "REVIEWED", direction = Relationship.Direction.INCOMING)
    List<Reviewer> reviewers;
}

@NodeEntity
public class Person {
    @Id
    String name;
}
----

Also, we add the generated internal id references to the relationship entities.

[source, java]
----
@RelationshipEntity(type = "ACTED_IN")
public class Actor {

    @Id @GeneratedValue
    Long id;

    List<String> roles;

    @StartNode
    Person person;

    @EndNode
    Movie movie;
}

@RelationshipEntity("REVIEWED")
public class Reviewer {

    @Id @GeneratedValue
    Long id;

    @Property("summary")
    String review;

    int rating;

    @EndNode
    Movie movie;

    @StartNode
    Person person;
}

----

[[tutorial:annotations:noarg-constructor]]
== No Arg Constructor

We are almost there!

Neo4j-OGM also requires a public no-args constructor to be able to construct objects from all our annotated entities.
Since we haven't defined any custom constructors, we are good to go.
